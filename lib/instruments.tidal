let __ = "~"



-- Def Utilities
:{

let values' op param paramvalues pat = zipWith (\src pat -> pat `op` param src) paramvalues pat
    values = values' (#)
    toID strr = Sound.Tidal.ID.ID strr

:}

-- let values' op param paramvalues pat = zipWith (\src pat -> op pat (param src)) paramvalues pat

-- Set/Load themes
:{
let themes name themes = mapM_ (uncurry setI)
      $ zip ((name ++) . show <$> [0..]) themes
    tm name num = cI_ (name ++ show num)
:}



-- Tidal Instruments
:{

let drums = p "drums"
               . stack
               . values orbit [0,0,1,1,2,2,3,3]
               . values pan [0,1,0,1,0,1,0,1]
               . values' (|*) gain (fmap (cF 0.5 . ("dg" ++) . show) [0,1,2,3,4,5,6,7])
    damp idx value = setF ("dg" ++ (show idx)) value
    da = damp
    damps amps = mapM_ (\(i,v) -> da i v) $ zip [0..7] (take 6 $ amps ++ repeat 0)
    dampall = damp . repeat

:}


-- Midi Instruments
:{
let mm pat = p "mm" $ pat # s "mm" # orbit 0 # midichan 15
    reface pat = p "reface" $ pat # s "reface" # orbit 0 # midichan 0
    
:}

-- Axoloti
:{
axocc :: Pattern Double -> Pattern Double -> ControlPattern
axocc ccnum ccpat = ccv ccpat # ccn ccnum
:}

:{
axoccs pats = p "axo"
                $ stack
                $ map (# s "axo")
                $ map (# midichan "0")
                $ pats
afx = axoccs
axo pats = p "axo"
             $ stack
             $ values midichan [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]
             $ map (# s "axo")
             $ pats
:}

-- Model:Cycles
:{
let mc pats = p "cycles"
      $ stack
      $ zipWith (\idx pat -> pat # amp (cF 0.5 $ "m" ++ (show idx) ++ "amp")) [0..]
      $ zipWith (\cycleschannel pat -> pat # s "mc" # midichan cycleschannel) [0, 1, 2, 3, 4, 5] pats
    mcTrack n time pat = xfadeIn (toID $ "cycles" ++ show n) time $ pat # s "mc" # midichan n
    m1' = mcTrack 0
    m2' = mcTrack 1
    m3' = mcTrack 2
    m4' = mcTrack 3
    m5' = mcTrack 4
    m6' = mcTrack 5
    m1 pat = do
      m1' 0.01 pat
      m1' 0.01 pat
    m2 pat = do
      m2' 0.01 pat
      m2' 0.01 pat
    m3 pat = do
      m3' 0.01 pat
      m3' 0.01 pat
    m4 pat = do
      m4' 0.01 pat
      m4' 0.01 pat
    m5 pat = do
      m5' 0.01 pat
      m5' 0.01 pat
    m6 pat = do
      m6' 0.01 pat
      m6' 0.01 pat
    cyclesDecayTime value = ccn 80 # ccv (value |* 125)
    cyclesColor     value = ccn 16 # ccv (value |* 125)
    cyclesShape     value = ccn 17 # ccv (value |* 125)
    cyclesSweep     value = ccn 18 # ccv (value |* 125)
    open = cyclesDecayTime
    mamp idx value = setF ("m" ++ (show idx) ++ "amp") value
    mamps amps = mapM_ (\(v,i) -> mamp i v) $ zip (take 6 $ amps ++ repeat 0) [0..5]
    mampall = mamp . repeat
    ma = mamp
:}

-- MIDI Track Setting: Remember to set AUTO channel to 16 (Cycles)
:{
let bank' chan device num = asap $ progNum num # s device # midichan chan
    bank = bank' 15
    mcbank num = asap $ progNum num # s "mc" # midichan 15
    fb chan num = bank' chan "fs" num
:}

-- TODO: chord-finding logic for model cycles
-- mcchordlist = [""]
-- chord name =


-- FM Synth helpers
:{
let fmamp op = pF ("amp" ++ show op)
    fmratio op = pF ("ratio" ++ show op)
    fmdetune op = pF ("detune" ++ show op)
    fmmod opa opb = pF ("mod" ++ show opa ++ show opb)
    fmegrate op step = pF ("egrate" ++ show op ++ show step)
    fmeglevel op step = pF ("eglevel" ++ show op ++ show step)
    fmfeedback = pF "feedback"
    fma = fmamp
    fmr = fmratio
    fmd = fmdetune
    fmm = fmmod
    fmf = fmfeedback
    fmer = fmegrate
    fmel = fmeglevel
    fmparam function = foldr (#) (gain 1) . zipWith function [1..]
    lfma = fmparam fma
    lfmr = fmparam fmr
    lfmd = fmparam fmd
    lfmer op = fmparam (fmer op)
    lfmel op = fmparam (fmel op)
:}

-- Synth Params

-- superhammond
:{
let vibrato = pF "vibrato"
    vrate = pF "vrate"
    perc = pF "perc"
    percf = pF "percf"
:}

-- supervibe
:{
let modamp = pF "modamp"
    modfreq = pF "modfreq"
:}


-- Interpretive
:{
let strum' dir i pat = fastcat ((arp dir pat):(take (fromInteger i) $ repeat (degradeBy 1 pat)))
    strum = strum' "up"
    humanize param amt = (|+ param (range (- (amt/10)) (amt/10) $ perlin))
    h = humanize
    hg = humanize gain
    :}


-- temp: looping functions
:{
let brakk' n = unit "c" # legato 1 # speed (1/n)
    brakk = brakk' 1
  :}

setF "mididelay" 0.04

-------------------------------------------------------------------- Instruments

:{
let virus idx pat = p (toID $ "virus" ++ show idx)
      $ ("^mididelay" <~)
      $ pat # midichan idx # s "fs"
    v = virus
:}
