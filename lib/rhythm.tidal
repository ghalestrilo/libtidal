-- Rhythm Builders | rd: rhythm define
:{
let rhythm' f x = map f . build x -- builds a rhythm passing a pattern builder and the voices
    rhythm x = rhythm n -- whar?
    gs pat a b = gain $ sew pat a b -- Helper function (gain . sew)
    l = build
    rd' f name patlist = (name, map f patlist)
    rd = rd' id
:}



-- TODO: Rhythm variations
:{
let var = pI "var"
    getVariation pat = maybe 0 ivalue <$> Map.lookup "var" <$> pat
:}
-- pass this into pickF (?)
-- in getVariation $ n "0 1 2" # var 4



 -- RHYTHM DICTIONARY
:{
let rhythms = Map.fromList $ l
      (rd "axe"      $ l "~ <[0 0] [0 0 ~ 0]>" (slow 2 $ "0*16" # gs "t f f t f f t t f f t f f t f f" "1.08" "0.85") "~")
      (rd "baiao"    $ l "0@3 0@5" ("0*4" # gs "f!2 t f" "0.8" "1"))
      (rd "brega"    $ l "0*2" "~@3 0 . ~ 0" "[0 0 0  ~]*2")
      (rd "ijexa"    $ l "[<[0!2] [0!2 ~!2]> ~]*2" "~ [f!2] . ~@3 f ~ f f ~")
      (rd "funk"     $ l "0(3,8) . ~ [0 ~] ~@2" "[~ 0]*2")
      (rd "funk150"  $ l "[t@3 ~@5 . ~ <~ t>@2 [~ <t ~>]]/2" "[~@3 f@3 f@2 . ~ f]/2")
      (rd "capoeira" $ l "~ ~ 0 ~" "~ ~ ~ 0")
      (rd "house"    $ l "0*2" "~ 0" "[~ 0]*2" ("[0 0 ~ 0]*2" |* gain 0.8))
      (rd "mrct1"    $ l
          "<[x@3 x@5] [[~ x]!2 . <x x>]>"
          "<x>@3 x"
          (fast 2 $ "x*4" # gain "1 0.8 0.9 0.8")
          (stack ["x*2", fast 2 $ "[~ x]*<1 1 2 1>" |+ up 5]))
      (rd' (slow (7/4))
        "t1" $ l "0@6 0@8" "~@3 0@3 ~@8" ("[0!3 ~]!3 <0 [0*2]>@0.5" # rel 0.2))
      (rd' (slow (7/4))
        "t2" $ l
          ("0@6 0!2 ~@6" |* rel "1 0.4")
          ("~@3 0@3 ~@4 0!2 ~@2" # gain "1 0.8" |* rel "1 0.3")
          ("[0!3 ~]!3 <0 [0*2]>@0.5" # rel 0.2))
:}
-- -- Indian - Taala-like
-- struct "[t@1.5 t]" $ n "2" # s "lo",
-- struct "<[t t t ~ ~] [~ t t t t]>" $ n "3 2 5" # s "lo",
-- struct "<[~ [t t] ~ ~ [t t]] [[t t] ~ ~ [t t] [t t]]>" $ n "3 5 3 5" # s "lo"
--
-- -- Cuban - basic Tumbao
-- d2 $ s "[ lo:4, ~ lo:3 ~ lo:3*2, lo:2*2 . [~ lo2]. lo:2*2 . [~ lo:2] ]"

-- rs: play a rhythm with a list of sounds
:{
let playrhythm rdef = (stack . zipWith (\pat inst -> pat # inst) rdef)
    findrhythm rname = case Map.lookup rname rhythms of
                          Just p -> p
                          Nothing -> do [("~" # gain 0)]
    r = playrhythm . findrhythm
    r' f rname = r rname . map f
    rs = r' s
:}



-- WIP: Second implementation using tidal dictionary (setF, cF_)
-- makertmname :: String -> Integer -> String
-- makertmname name idx = "rtm_" ++ name ++ "_" ++ (show idx)
--
--
-- makerhythmpairs :: String -> [Pattern Double] -> [(String, Pattern Double)]
-- makerhythmpairs name patlist = zipWith (\x y -> (makertmname name x, y)) [0..] patlist
--
-- defrhythm :: String -> [Pattern Double] -> IO ()
-- defrhythm name list@(p:ps) = setF (makertmname name 0) (list!!0)
-- defrhythm name [] = print "no patterns"
--
-- defrhythm "testaaa" [(rev . sometimes (fast 2) . scale "major") "[0 2 4 7]*2"]
--
-- getpat :: String -> Pattern Double
-- getpat name = cF_ (makertmname name 0)






-- Sketchboard

-- do (sequence . map (\(x, y) -> setF x y)) [("hahalol", "[1 1 1 ~]*2")]
--
-- do (sequence . map (\(x, y) -> setF x y)) [("hahalol", "[1 1 1 ~]*2")]
--
-- mapM_ (\(x, y) -> setF x y) [("hahalol", "[1 1 1 ~]*2")]
--
--
-- d1 $ note (getpat "hahalol") # s "bd" # gain 1


-- Example
-- -- setF "haha1" "c a f d"
-- -- d1 $ n (cF_ "haha1") # s "superpiano"
-- -- print $ show (cF_ "haha1")
